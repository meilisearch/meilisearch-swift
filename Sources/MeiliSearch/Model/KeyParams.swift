import Foundation
#if canImport(FoundationNetworking)
  import FoundationNetworking
#endif

/**
 `KeyParams` contains all the parameters to create an API key.
 */
public struct KeyParams: Codable, Equatable {
  /// A description for the key.
  public var description: String?
  /// A human-readable name for the key.
  public var name: String?
  /// A uuid v4 to identify the API key. If not specified, it is automatically generated by Meilisearch.
  public var uid: String?
  /// An array of API actions permitted for the key.
  public let actions: [KeyAction]
  /// An array of strings (indexes names) the key is authorized to act on.
  public let indexes: [String]
  /// Date and time when the key will expire, represented in RFC 3339 format.
  public let expiresAt: String?

  public init(
    description: String? = nil,
    name: String? = nil,
    uid: String? = nil,
    actions: [KeyAction],
    indexes: [String],
    expiresAt: String?
  ) {
    self.description = description
    self.name = name
    self.uid = uid
    self.actions = actions
    self.indexes = indexes
    self.expiresAt = expiresAt
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)

    if uid != nil {
      try container.encode(uid, forKey: .uid)
    }

    try container.encode(name, forKey: .name)
    try container.encode(description, forKey: .description)
    try container.encode(actions, forKey: .actions)
    try container.encode(indexes, forKey: .indexes)
    try container.encode(expiresAt, forKey: .expiresAt)
  }
}

public struct KeyUpdateParams: Codable, Equatable {
  public var description: String?
  public var name: String?

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)

    if description != nil {
      try container.encode(description, forKey: .description)
    }

    if name != nil {
      try container.encode(name, forKey: .name)
    }
  }
}
